/** 
 * @file NearestGeoPoint.java
 * @class richTrident.examples.NearestGeoPoint
 * @brief This is an example showing how to use RichStream to get the nearest geopoint.
 * @author Guang Jin
 * @email jin_guang@hotmail.com
 **/
package richTrident.examples;

import com.jin.storm.richTrident.RichTridentTopology;
import com.jin.storm.richTrident.geo.GeoPoint;
import com.jin.storm.richTrident.geo.RTreeMap;
import com.jin.storm.richTrident.geo.operation.NearestPostRichQueryFunction;
import com.jin.storm.richTrident.geo.operation.NearestPreRichQueryFunction;

import storm.trident.TridentState;
import storm.trident.operation.BaseFunction;
import storm.trident.operation.TridentCollector;
import storm.trident.testing.FixedBatchSpout;
import storm.trident.tuple.TridentTuple;
import backtype.storm.Config;
import backtype.storm.LocalCluster;
import backtype.storm.LocalDRPC;
import backtype.storm.StormSubmitter;
import backtype.storm.generated.StormTopology;
import backtype.storm.tuple.Fields;
import backtype.storm.tuple.Values;

public class NearestGeoPoint {
	public static class GenGeoPoint extends BaseFunction {//a function to generate GeoPoint from input argument string
		@Override
		public void execute(TridentTuple tuple, TridentCollector collector) {
			String sentence = tuple.getString(0);
			String[] cordinates = sentence.split(" ");
			collector.emit(new Values(new GeoPoint(Float.parseFloat(cordinates[0]), Float.parseFloat(cordinates[1]))));
		}
	}
	
	public static StormTopology buildTopology(LocalDRPC drpc) {
		RichTridentTopology topology = new RichTridentTopology();
	    
	    String[] fieldNames = {"id","point"};
		FixedBatchSpout pointSpout = new FixedBatchSpout(new Fields(fieldNames), 4,
				new Values("Mark",new GeoPoint(1,1)), new Values("Smith",new GeoPoint(2,2)), 
				new Values("John",new GeoPoint(3,3)), new Values("Mary",new GeoPoint(4,4)), 
				new Values("Tom",new GeoPoint(5,5)), new Values("Brittany", new GeoPoint(6,6)));
		pointSpout.setCycle(true);//a spout to generate id and geoPoint pairs

		TridentState geoPointState = topology.newRichStream("geoPoint", pointSpout)//one stream for a tuples with id and GeoPoint
										.distributePersist(new Fields("id"), new Fields("point"), new RTreeMap())//distribute the tuples based on their ids and index the value by a RTreeMap (a Rtree is used)
										.parallelismHint(5);//5 worker nodes running to maintain the state
		
		topology.newDRPCStream("drpc", drpc).each(new Fields("args"), new GenGeoPoint(), new Fields("value"))//another stream is generated by a drpc through its args(see GenGeoPoint function which parse the input args string into GeoPoint)
				.stateRichQuery(geoPointState,//query the state which holds the geoPoints
						new Fields("value"), //the drpc stream provides the value field which holds GeoPoints 
						new NearestPreRichQueryFunction(), //preQuery gets the coarse results
						new NearestPostRichQueryFunction(new Fields("point")), //postQuery refines based on the point field from pointSpout tuples
						new Fields("nearest"));//generate a new field for the final results
		return topology.build();
	}
	
	public static void main(String[] args) throws Exception {
		Config conf = new Config();
		conf.setMaxSpoutPending(20);
		if (args.length == 0) {
			LocalDRPC drpc = new LocalDRPC();
			LocalCluster cluster = new LocalCluster();
			cluster.submitTopology("richTrident", conf, buildTopology(drpc));
			for (int i = 0; i < 100; i++) {
				System.out.println("DRPC RESULT: "+ drpc.execute("drpc", i+" "+(i+1)));
				Thread.sleep(1000);
			}
		} else {
			conf.setNumWorkers(3);
			StormSubmitter.submitTopologyWithProgressBar(args[0], conf,
					buildTopology(null));
		}
	}

}
