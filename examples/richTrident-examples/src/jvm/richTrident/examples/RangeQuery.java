/** 
 * @file RangeQuery.java
 * @class richTrident.examples.RangeQuery
 * @brief This is an example showing how to use RichStream to get the value within a range.
 * @author Guang Jin
 * @email jin_guang@hotmail.com
 **/
package richTrident.examples;

import java.util.TreeMap;

import com.jin.storm.richTrident.RichTridentTopology;
import com.jin.storm.richTrident.operation.RangePostRichQueryFunction;
import com.jin.storm.richTrident.operation.RangePreRichQueryFunction;

import storm.trident.TridentState;
import storm.trident.operation.BaseFunction;
import storm.trident.operation.TridentCollector;
import storm.trident.testing.FixedBatchSpout;
import storm.trident.tuple.TridentTuple;
import backtype.storm.Config;
import backtype.storm.LocalCluster;
import backtype.storm.LocalDRPC;
import backtype.storm.StormSubmitter;
import backtype.storm.generated.StormTopology;
import backtype.storm.tuple.Fields;
import backtype.storm.tuple.Values;

public class RangeQuery {
	
	  public static class Range extends BaseFunction {
		    @Override
		    public void execute(TridentTuple tuple, TridentCollector collector) {
		      String sentence = tuple.getString(0);
		      String[] values = sentence.split(" ");
		      collector.emit(new Values(new Integer(values[0]), new Integer(values[1])));
		    }
		  }

	public static StormTopology buildTopology(LocalDRPC drpc) {
		RichTridentTopology topology = new RichTridentTopology();
	    
	    String[] fieldNames = {"id","value"};
		FixedBatchSpout studentSpout = new FixedBatchSpout(new Fields(fieldNames), 1,
				new Values("Mark",new Integer(1)), 
				new Values("Smith",new Integer(2)), 
				new Values("Joe",new Integer(3)), 
				new Values("Mary",new Integer(4)), 
				new Values("Tom",new Integer(5)), 
				new Values("Brittany", new Integer(6)),
				new Values("William", new Integer(2)));
		studentSpout.setCycle(true);//a spout to generate id and value pairs

		TridentState richState = topology.newRichStream("student", studentSpout)//one stream for a tuples with id and value
									.distributePersist(new Fields("id"), new Fields("value"), new TreeMap())//distribute the tuples based on their ids and index the value by a TreeMap (a black-red tree actually)
									.parallelismHint(5);//5 worker nodes running to maintain the state
		
		topology.newDRPCStream("drpc", drpc).each(new Fields("args"), new Range(), new Fields("lower","upper"))//another stream is generated by a drpc through its args(see range function which parse the input args string into a range)
				.stateRichQuery(richState,//query the state 
						new Fields("lower","upper"), //the drpc provides the fields to define a range
						new RangePreRichQueryFunction(new Fields("lower"), true, new Fields("upper"), true),//preQuery gets the range defined by the inclusive lower and inclusive upper range 
						new RangePostRichQueryFunction(new Fields("value")),//postQuery just combines the received results 
						new Fields("withinRange"));//generate a new field for the matched results 
		return topology.build();
	}

	public static void main(String[] args) throws Exception {
		Config conf = new Config();
		conf.setMaxSpoutPending(20);
		if (args.length == 0) {
			LocalDRPC drpc = new LocalDRPC();
			LocalCluster cluster = new LocalCluster();
			cluster.submitTopology("richTrident", conf, buildTopology(drpc));
			for (int i = 0; i < 100; i++) {
				System.out.println("DRPC RESULT: "+ drpc.execute("drpc", "2 5"));
				Thread.sleep(1000);
			}
		} else {
			conf.setNumWorkers(3);
			StormSubmitter.submitTopologyWithProgressBar(args[0], conf,
					buildTopology(null));
		}
	}
}